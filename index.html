<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Masters - Card Matching Game</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .card-inner {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }
        .card.is-flipped .card-inner {
            transform: rotateY(180deg);
        }
        .card-front,
        .card-back {
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        .card-back {
            transform: rotateY(180deg);
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                filter: brightness(1);
            }
            50% {
                transform: scale(1.02);
                filter: brightness(1.1);
            }
        }
        .is-critical {
            animation: pulse 1.5s infinite ease-in-out;
        }

        @keyframes fade-in-up {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .animate-fade-in-up {
            animation: fade-in-up 0.4s ease-out forwards;
        }
    </style>
</head>
<body class="bg-slate-900 text-white font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback, useEffect, useMemo } = React;

        // Constants
        const EMOJIS = [
            '🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐨', '🐯',
            '🦁', '🐮', '🐷', '🐸', '🐵', '🐔', '🐧', '🐦', '🐤', '🦆',
            '🦅', '🦉', '🦇', '🐺', '🐗', '🐴', '🦄', '🐝', '🐛', '🦋',
            '🐌', '🐞', '🐜', '🦟', '🦗', '🕷', '🦂', '🐢', '🐍', '🦎',
            '🦖', '🦕', '🐙', '🦑', '🦐', '🦞', '🦀', '🐡', '🐠', '🐟',
            '🐬', '🐳', '🐋', '🦈', '🐊', '🐅', '🐆', '🦓', '🦍', '🦧',
            '🐘', '🦛', '🦏', '🐪', '🐫', '🦒', '🦘', '🐃', '🐂', '🐄',
            '🐎', '🐖', '🐏', '🐑', '🦙', '🐐', '🦌', '🐕', '🐩', '🦮',
            '🐕‍🦺', '🐈', '🐈‍⬛', '🐓', '🦃', '🦤', '🦚', '🦜', '🦢', '🦩'
        ];

        const LEVEL_CONFIGS = [
            { level: 1,  pairs: 2,  grid: [2, 2], timeLimit: 20 },
            { level: 2,  pairs: 4,  grid: [2, 4], timeLimit: 40 },
            { level: 3,  pairs: 6,  grid: [3, 4], timeLimit: 60 },
            { level: 4,  pairs: 8,  grid: [4, 4], timeLimit: 80 },
            { level: 5,  pairs: 9,  grid: [3, 6], timeLimit: 85 },
            { level: 6,  pairs: 10, grid: [4, 5], timeLimit: 90 },
            { level: 7,  pairs: 12, grid: [4, 6], timeLimit: 110 },
            { level: 8,  pairs: 14, grid: [4, 7], timeLimit: 125 },
            { level: 9,  pairs: 15, grid: [5, 6], timeLimit: 120 },
            { level: 10, pairs: 16, grid: [4, 8], timeLimit: 130 },
            { level: 11, pairs: 18, grid: [6, 6], timeLimit: 145 },
            { level: 12, pairs: 20, grid: [5, 8], timeLimit: 160 },
            { level: 13, pairs: 21, grid: [6, 7], timeLimit: 150 },
            { level: 14, pairs: 22, grid: [4, 11], timeLimit: 155 },
            { level: 15, pairs: 24, grid: [6, 8], timeLimit: 170 },
            { level: 16, pairs: 25, grid: [5, 10], timeLimit: 175 },
            { level: 17, pairs: 27, grid: [6, 9], timeLimit: 175 },
            { level: 18, pairs: 28, grid: [7, 8], timeLimit: 180 },
            { level: 19, pairs: 30, grid: [6, 10], timeLimit: 195 },
            { level: 20, pairs: 32, grid: [8, 8], timeLimit: 210 },
        ];

        const GameStatus = {
            NOT_STARTED: 'NOT_STARTED',
            PLAYING: 'PLAYING',
            LEVEL_CLEARED: 'LEVEL_CLEARED',
            GAME_OVER: 'GAME_OVER',
            GAME_WON_ALL: 'GAME_WON_ALL',
        };

        const TICK_SOUND_SRC = "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+nzvmgfCjaP1vLNeSsFJXfH8N+OSAgUXrXp6qZMFAlFn+fwvmkgCjaP1/LPfCkGKXbH7uGOQQwUXbrq56FNCApFnnfwvmogCjiN1/DNew4HJ3fH8N+SOAwTXrjq66RRGgsrGh4STKEBJp6K7DXRoHsNlI2VEDxhMhKhTgGQmJoSRBuYBXCd3xNqe7sGuJkV8MgEQaLBKW68xiRpJOO7TrKWNO1xeALZN9GGPO9TtFE5C3S5F5yNzaWNfXCRj4KwWWgbYHGsAexXgOZjdKCYJHiYE";

        // Components
        const QuestionMarkIcon = () => (
            React.createElement('svg', {
                xmlns: "http://www.w3.org/2000/svg",
                className: "h-1/2 w-1/2 text-slate-400",
                fill: "none",
                viewBox: "0 0 24 24",
                stroke: "currentColor"
            },
            React.createElement('path', {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                strokeWidth: 2,
                d: "M8.228 9c.09-.977.546-1.873 1.262-2.587C10.215 5.699 11.11 5.243 12.086 5.142c.976-.1 1.951.158 2.761.728.81.57 1.392 1.417 1.654 2.38.25 1 0 2-.5 2.75s-1.25 1.5-2 2-1.5 1.75-1.5 2.75"
            }),
            React.createElement('path', {
                d: "M12 19.01L12.01 18.999",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round"
            }))
        );

        const TimerIcon = () => (
            React.createElement('svg', {
                xmlns: "http://www.w3.org/2000/svg",
                className: "h-6 w-6 mr-2 text-sky-400",
                fill: "none",
                viewBox: "0 0 24 24",
                stroke: "currentColor"
            },
            React.createElement('path', {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                strokeWidth: 2,
                d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
            }))
        );

        const RestartIcon = () => (
            React.createElement('svg', {
                xmlns: "http://www.w3.org/2000/svg",
                className: "h-5 w-5 text-slate-300",
                fill: "none",
                viewBox: "0 0 24 24",
                stroke: "currentColor",
                strokeWidth: 2
            },
            React.createElement('path', {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                d: "M4 4v5h5M20 20v-5h-5"
            }),
            React.createElement('path', {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                d: "M4 9a9 9 0 0114.65-4.65l1.35 1.35M20 15a9 9 0 01-14.65 4.65l-1.35-1.35"
            }))
        );

        const Card = ({ card, onClick, isDisabled }) => {
            const handleClick = () => {
                if (!isDisabled && !card.isFlipped && !card.isMatched) {
                    onClick(card.id);
                }
            };

            const cardClasses = `card w-full h-full perspective-1000 ${
                card.isFlipped || card.isMatched ? 'is-flipped' : ''
            }`;
            const cursorClass = !isDisabled && !card.isFlipped && !card.isMatched ? 'cursor-pointer' : 'cursor-default';

            return React.createElement('div', {
                className: cardClasses,
                onClick: handleClick
            },
                React.createElement('div', {
                    className: `card-inner relative w-full h-full ${cursorClass}`
                },
                    React.createElement('div', {
                        className: "card-front absolute w-full h-full rounded-lg bg-slate-700 hover:bg-slate-600 flex items-center justify-center transition-colors duration-300"
                    },
                        React.createElement(QuestionMarkIcon)
                    ),
                    React.createElement('div', {
                        className: `card-back absolute w-full h-full rounded-lg flex items-center justify-center text-4xl md:text-5xl ${card.isMatched ? 'bg-emerald-500' : 'bg-blue-500'}`
                    }, card.value)
                )
            );
        };

        const Timer = ({ timeLeft, timeLimit }) => {
            const percentage = (timeLeft / timeLimit) * 100;
            const isCritical = percentage <= 25;

            const barColorClass =
                percentage > 50
                    ? 'from-green-500 to-cyan-500'
                    : percentage > 25
                        ? 'from-yellow-400 to-orange-500'
                        : 'from-red-500 to-rose-600';

            const timerBarClasses = `
                absolute left-0 top-0 h-full rounded-full bg-gradient-to-r ${barColorClass}
                transition-all duration-300
                ${isCritical ? 'is-critical' : ''}
            `;

            return React.createElement('div', {
                className: "w-full bg-slate-700 rounded-full h-8 p-1 flex items-center relative overflow-hidden shadow-inner"
            },
                React.createElement('div', {
                    className: "flex items-center z-10 pl-2"
                },
                    React.createElement(TimerIcon),
                    React.createElement('span', {
                        className: "font-bold text-sm text-white",
                        style: { textShadow: '0 0 5px rgba(0,0,0,0.7)' }
                    }, `${timeLeft}s`)
                ),
                React.createElement('div', {
                    className: timerBarClasses,
                    style: { width: `${Math.max(0, percentage)}%`, transitionProperty: 'width, background-color' }
                })
            );
        };

        const Modal = ({ title, children }) => {
            return React.createElement('div', {
                className: "fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4"
            },
                React.createElement('div', {
                    className: "bg-slate-800 rounded-xl shadow-2xl p-8 max-w-sm w-full mx-auto transform animate-fade-in-up"
                },
                    React.createElement('h2', {
                        className: "text-3xl font-bold text-center mb-6 text-transparent bg-clip-text bg-gradient-to-r from-sky-400 to-blue-500"
                    }, title),
                    React.createElement('div', {
                        className: "space-y-4"
                    }, children)
                )
            );
        };

        // Fisher-Yates shuffle algorithm
        const shuffleArray = (array) => {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        };

        const GameBoard = ({ levelConfig, onLevelComplete, onGameOver, onRestartRequest, audio }) => {
            const [cards, setCards] = useState([]);
            const [flippedIndices, setFlippedIndices] = useState([]);
            const [matchedPairs, setMatchedPairs] = useState(0);
            const [isChecking, setIsChecking] = useState(false);
            const [isPreview, setIsPreview] = useState(true);
            const [timeLeft, setTimeLeft] = useState(levelConfig.timeLimit);

            const [rows, cols] = levelConfig.grid;

            const generateCards = useCallback((config) => {
                const selectedEmojis = shuffleArray(EMOJIS).slice(0, config.pairs);
                const cardValues = shuffleArray([...selectedEmojis, ...selectedEmojis]);
                return cardValues.map((value, index) => ({
                    id: index,
                    value,
                    isFlipped: true,
                    isMatched: false,
                }));
            }, []);

            useEffect(() => {
                setCards(generateCards(levelConfig));
                setMatchedPairs(0);
                setFlippedIndices([]);
                setIsChecking(false);
                setIsPreview(true);
                setTimeLeft(levelConfig.timeLimit);
            }, [levelConfig, generateCards]);

            useEffect(() => {
                if (isPreview) {
                    const previewDuration = Math.max(1500, Math.min(4000, 1000 + levelConfig.pairs * 100));
                    const timer = setTimeout(() => {
                        setCards(prev => prev.map(c => ({ ...c, isFlipped: false })));
                        setIsPreview(false);
                    }, previewDuration);
                    return () => clearTimeout(timer);
                }
            }, [isPreview, levelConfig]);

            useEffect(() => {
                if (isPreview || timeLeft <= 0 || matchedPairs === levelConfig.pairs) {
                    return;
                }

                const timer = setTimeout(() => setTimeLeft(timeLeft - 1), 1000);
                return () => clearTimeout(timer);
            }, [isPreview, timeLeft, matchedPairs, levelConfig.pairs]);

            useEffect(() => {
                if (!isPreview && timeLeft === 0 && matchedPairs < levelConfig.pairs) {
                    onGameOver();
                }
            }, [timeLeft, isPreview, onGameOver, matchedPairs, levelConfig.pairs]);

            useEffect(() => {
                if (matchedPairs === levelConfig.pairs && levelConfig.pairs > 0) {
                    const timer = setTimeout(() => {
                        onLevelComplete();
                    }, 1000);
                    return () => clearTimeout(timer);
                }
            }, [matchedPairs, levelConfig.pairs, onLevelComplete]);

            useEffect(() => {
                if (flippedIndices.length < 2) return;

                setIsChecking(true);
                const [firstIndex, secondIndex] = flippedIndices;

                const timer = setTimeout(() => {
                    setCards(prevCards => {
                        const card1 = prevCards[firstIndex];
                        const card2 = prevCards[secondIndex];

                        if (card1.value === card2.value) {
                            setMatchedPairs(prev => prev + 1);
                            return prevCards.map(card =>
                                card.value === card1.value ? { ...card, isMatched: true } : card
                            );
                        } else {
                            return prevCards.map((card, index) =>
                                index === firstIndex || index === secondIndex ? { ...card, isFlipped: false } : card
                            );
                        }
                    });
                    setFlippedIndices([]);
                    setIsChecking(false);
                }, 800);

                return () => clearTimeout(timer);
            }, [flippedIndices]);

            const handleCardClick = useCallback((id) => {
                if (isChecking || isPreview) return;

                setCards(prevCards => {
                    const flippedUnmatched = prevCards.filter(c => c.isFlipped && !c.isMatched).length;
                    if (flippedUnmatched >= 2) return prevCards;

                    const cardIndex = prevCards.findIndex(c => c.id === id);
                    if (cardIndex === -1 || prevCards[cardIndex].isFlipped || prevCards[cardIndex].isMatched) {
                        return prevCards;
                    }

                    setFlippedIndices(prev => [...prev, cardIndex]);

                    const newCards = [...prevCards];
                    newCards[cardIndex] = { ...newCards[cardIndex], isFlipped: true };
                    return newCards;
                });
            }, [isChecking, isPreview]);

            const gridStyle = useMemo(() => ({
                gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))`,
                gridTemplateRows: `repeat(${rows}, minmax(0, 1fr))`
            }), [cols, rows]);

            return React.createElement('div', {
                className: "w-full max-w-5xl mx-auto p-4 flex flex-col items-center"
            },
                React.createElement('div', {
                    className: "w-full flex justify-between items-center mb-4 px-2"
                },
                    React.createElement('h2', {
                        className: "text-2xl font-bold text-sky-300"
                    }, `Level ${levelConfig.level}`),
                    React.createElement('div', {
                        className: "flex items-center space-x-4"
                    },
                        React.createElement('div', {
                            className: "text-xl font-semibold"
                        }, `${matchedPairs} / ${levelConfig.pairs} Pairs`),
                        React.createElement('button', {
                            onClick: onRestartRequest,
                            className: "p-2 rounded-full bg-slate-700 hover:bg-slate-600 transition-colors",
                            title: "Restart Game"
                        }, React.createElement(RestartIcon))
                    )
                ),
                React.createElement('div', {
                    className: "w-full mb-6 relative"
                },
                    React.createElement(Timer, {
                        timeLeft: timeLeft,
                        timeLimit: levelConfig.timeLimit
                    })
                ),
                React.createElement('div', {
                    className: "w-full aspect-video p-2 bg-slate-800 rounded-lg shadow-inner relative"
                },
                    isPreview && React.createElement('div', {
                        className: "absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center z-20 rounded-lg"
                    },
                        React.createElement('div', {
                            className: "text-center"
                        },
                            React.createElement('h3', {
                                className: "text-4xl font-bold text-yellow-300 animate-pulse"
                            }, "Memorize!"),
                            React.createElement('p', {
                                className: "text-slate-200 mt-2"
                            }, "Get ready...")
                        )
                    ),
                    React.createElement('div', {
                        className: "grid gap-2 md:gap-3 w-full h-full",
                        style: gridStyle
                    },
                        cards.map((card) =>
                            React.createElement(Card, {
                                key: card.id,
                                card: card,
                                onClick: handleCardClick,
                                isDisabled: isChecking || isPreview
                            })
                        )
                    )
                )
            );
        };

        const App = () => {
            const [gameStatus, setGameStatus] = useState(GameStatus.NOT_STARTED);
            const [currentLevel, setCurrentLevel] = useState(1);
            const [gameInstance, setGameInstance] = useState(0);
            const [audio, setAudio] = useState(null);

            const maxLevel = LEVEL_CONFIGS.length;

            const handleStartGame = () => {
                if (!audio) {
                    try {
                        const tickSound = new Audio(TICK_SOUND_SRC);
                        tickSound.preload = 'auto';
                        setAudio(tickSound);
                    } catch (e) {
                        console.warn("Audio initialization failed:", e);
                    }
                }
                setCurrentLevel(1);
                setGameStatus(GameStatus.PLAYING);
                setGameInstance(prev => prev + 1);
            };

            const handleNextLevel = () => {
                if (currentLevel < maxLevel) {
                    setCurrentLevel(prev => prev + 1);
                    setGameStatus(GameStatus.PLAYING);
                } else {
                    setGameStatus(GameStatus.GAME_WON_ALL);
                }
            };

            const handleTryAgain = () => {
                setGameStatus(GameStatus.PLAYING);
                setGameInstance(prev => prev + 1);
            };

            const handleLevelComplete = useCallback(() => {
                if (currentLevel === maxLevel) {
                    setGameStatus(GameStatus.GAME_WON_ALL);
                } else {
                    setGameStatus(GameStatus.LEVEL_CLEARED);
                }
            }, [currentLevel, maxLevel]);

            const handleGameOver = useCallback(() => {
                setGameStatus(GameStatus.GAME_OVER);
            }, []);

            const renderContent = () => {
                switch (gameStatus) {
                    case GameStatus.NOT_STARTED:
                        return React.createElement('div', {
                            className: "text-center"
                        },
                            React.createElement('h1', {
                                className: "text-5xl md:text-7xl font-bold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-sky-400 to-blue-600"
                            }, "Memory Masters"),
                            React.createElement('p', {
                                className: "text-slate-300 mb-8 text-lg"
                            }, "Test your memory against the clock. Can you beat all 20 levels?"),
                            React.createElement('button', {
                                onClick: handleStartGame,
                                className: "bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full text-xl transition-transform transform hover:scale-105"
                            }, "Start Game")
                        );
                    case GameStatus.PLAYING:
                        return React.createElement(GameBoard, {
                            key: `${currentLevel}-${gameInstance}`,
                            levelConfig: LEVEL_CONFIGS[currentLevel - 1],
                            onLevelComplete: handleLevelComplete,
                            onGameOver: handleGameOver,
                            onRestartRequest: handleStartGame,
                            audio: audio
                        });
                    case GameStatus.LEVEL_CLEARED:
                        return React.createElement(Modal, {
                            title: `Level ${currentLevel} Cleared!`
                        },
                            React.createElement('p', {
                                className: "text-center text-slate-300"
                            }, "Excellent work! Get ready for the next challenge."),
                            React.createElement('button', {
                                onClick: handleNextLevel,
                                className: "w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105"
                            }, "Next Level")
                        );
                    case GameStatus.GAME_OVER:
                        return React.createElement(Modal, {
                            title: "Game Over"
                        },
                            React.createElement('p', {
                                className: "text-center text-slate-300"
                            }, "Time's up! Don't give up, give it another shot."),
                            React.createElement('div', {
                                className: "flex space-x-4"
                            },
                                React.createElement('button', {
                                    onClick: handleTryAgain,
                                    className: "w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105"
                                }, "Try Again"),
                                React.createElement('button', {
                                    onClick: handleStartGame,
                                    className: "w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105"
                                }, "Restart")
                            )
                        );
                    case GameStatus.GAME_WON_ALL:
                        return React.createElement(Modal, {
                            title: "Congratulations!"
                        },
                            React.createElement('p', {
                                className: "text-center text-slate-300"
                            }, `You are a true Memory Master! You've completed all ${maxLevel} levels.`),
                            React.createElement('button', {
                                onClick: handleStartGame,
                                className: "w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-transform transform hover:scale-105"
                            }, "Play Again")
                        );
                }
            };

            return React.createElement('main', {
                className: "min-h-screen w-full flex items-center justify-center p-4 bg-slate-900"
            }, renderContent());
        };

        // Render the app
        ReactDOM.render(React.createElement(App), document.getElementById('root'));
    </script>
</body>
</html>